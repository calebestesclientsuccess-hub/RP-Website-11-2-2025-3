Project Cygnus: Implementation Sprint Plan (v2.0)



Based on: Project Cygnus: Comprehensive Technical Specification v2.0

Lead: [Your Name]

Est. Time: 1-2 Sprints (6-8 hours, given our new economics)



This plan organizes the 8 tasks from our v2.0 spec into parallel workstreams.



Sprint 1: Backend Foundation & API Core



Owner: Backend Team

Est. Time: 3-4 hours

Goal: Establish the database schema and all core CRUD/recycle logic. The platform should be fully functional via API by the end of this sprint.



Tasks:



[Task 1] Set Up Storage:



Implement the sceneTemplates table in shared/schema.ts as defined in v2.0 spec (with tenantId, schemaVersion, etc.).



Implement all indexes (tenant_id_idx, category_idx, search_idx).



Run Drizzle migration (npm run db:push --force).



[Task 2] Implement "Save As" Endpoint:



Build POST /api/scene-templates/create-from-scene.



Implement all validation: Zod schema, tenant ownership of the source scene, and the critical media validation logic (checking all mediaIds against media_library for correct tenancy).



[Task 3] Implement "List" Endpoint:



Build GET /api/scene-templates.



Implement all filtering logic: category, tag, search.



Implement all sorting logic: recent, popular, name.



[Task 4] Implement "Recycle" Endpoint:



Build POST /api/projects/:projectId/scenes/recycle.



Implement all validation: project ownership, template ownership (must match tenant).



Implement media validation (graceful degradation: strip orphaned mediaIds).



Implement scene ordering logic (append to end or insert-and-shift).



Implement customizations logic (applying content and director overrides).



Implement usageCount and lastUsedAt analytics update on the template.



[Task 5] Implement "Change/Remove" Endpoints:



Build PATCH /api/scene-templates/:id (for metadata changes).



Build DELETE /api/scene-templates/:id (for deletion).



Ensure tenant isolation is checked on both.



Sprint 2: Frontend Interface & AI Integration



Owner: Frontend Team & AI Lead

Est. Time: 3-4 hours (Can be run in parallel with Sprint 1)



Tasks:



[Task 6 & 7] Build Recycler Modal & Cards:



Implement the SceneRecyclerModal.tsx component as specified.



Implement the TemplateCard.tsx sub-component.



Build the UI for all search, category tabs, and tag filters.



Integrate the useQuery call to GET /api/scene-templates with debounced search.



[Task 8] Build "Save As" UI:



Implement the SaveAsTemplateButton.tsx and its modal.



Build the form (name, description, tags) and integrate the useMutation hook to call POST /api/scene-templates/create-from-scene.



Add this button to the ProjectSceneEditor UI.



[Task 8, cont.] Build "Recycle" Hook:



Implement the useRecycleScene.ts hook (useMutation).



Ensure its onSuccess callback invalidates the project's scene list query (queryKey: ['/api/projects', projectId, 'scenes']).



Hook this up to the "Add to Project" button in TemplateCard.tsx.



[AI Task] Implement AI Integration:



Modify server/utils/portfolio-director.ts.



Fetch the availableTemplates list (top 20, filtered by tenant) from the DB.



Inject the AVAILABLE_SCENE_TEMPLATES block into the system prompt context.



Add the CRITICAL_INSTRUCTIONS_FOR_TEMPLATE_USAGE to the prompt.



Add the post-generation logging to track _sourceTemplateId usage.



Sign-Off Criteria (Definition of Done):



A user can click "Save as Template" on a scene, and it appears in the scene_templates table.



A user can open the "Add from Library" modal and see a visual gallery of their saved templates.



A user can click "Add to Project," and the scene (with all media and animations) is perfectly cloned into their project.



The AI, when asked to "add a dark testimonial," generates a scene using the tmpl_quote_dark_01 template, and the server logs show the _sourceTemplateId was used.



All 4 of these actions are fully isolated by tenantId.





Please mediate on the plan below. You may ask questions if you would to. This is a multiphased plan which will execute one piece at a time.

Your requirement is to read, study, and ask questions. Do not begin building yet, because I have one last piece of critical instruction about the first phase.

After you complete a section your requirement is to report on what you did, list all acceptance criteria completed and incomplete and ask any questions you must ask in order to proceed to the next step fully equipped and empowered to work in compliance with our vision.

CE





Assistant

55 minutes ago



Read 38 files



I've carefully reviewed Project Cygnus: Scene Recycler System Implementation Plan v2.1. This is a well-structured, multi-phase plan for building a scene template library system that allows users to save, browse, and reuse scene configurations across projects.

My Understanding

Core Purpose: Enable users to:

Save any scene as a reusable template

Browse a visual library of templates with search/filter

"Recycle" templates into new projects (creating new scenes from templates)

Have AI automatically use templates when generating scenes

Key Architecture Points I've Noted:

Multi-tenant isolation - All operations must respect tenantId boundaries

Media validation - Critical security concern: templates can only reference media that belongs to the same tenant

Orphaned media handling - Graceful degradation when template references media that no longer exists

React Query cache invalidation - Ensures UI updates immediately after operations

AI integration - Templates become part of AI's context for scene generation

Questions Before We Begin

1. Existing Infrastructure Verification

I see references to req.tenantId throughout the plan. Can you confirm that tenant middleware is already active and populating req.tenantId on all requests? (I saw tenant-resolver.ts in the codebase)

Is the current session system already tenant-aware, or will we need to enhance authentication?

2. Media Library Status

The plan assumes media_library table exists with tenantId foreign keys. Can you confirm this table is fully implemented and in production use?

Are Media Library assets already linked to projects via projectId, or is that relationship new?

3. ProjectSceneEditor Integration Point

Sprint 2.4 requires integrating into ProjectSceneEditor.tsx. I can see this file exists. Should I verify the current scene list structure before proceeding, or do you have a specific location in mind for the "Add from Library" button?

4. AI Endpoint Confirmation

Sprint 3.1 mentions modifying /api/portfolio/generate-enhanced around line 2456. Should I locate this exact endpoint first, or are line numbers approximate?

Is there already a pattern for how AI context is built that I should follow?

5. Database Migration Strategy

Sprint 0 uses npm run db:push --force. Is this the preferred approach, or should I generate a proper migration file in the migrations/ folder for production safety?

6. Testing Expectations

The plan mentions curl/Postman testing for Sprint 1 checkpoint. Do you want me to:Just implement the endpoints?

Also provide example curl commands for testing?

Write integration tests in the tests/integration/ folder?

7. Preview Image Strategy

Templates have previewImageUrl field. For auto-generation, should this:Pull from content.url for image/video scenes?

Generate a placeholder/screenshot somehow?

Remain null if no media exists?

8. Critical Instruction You Mentioned

You said: "I have one last piece of critical instruction about the first phase."

I'm ready to receive this instruction before beginning Sprint 0.

What I'm Prepared to Execute

Once you provide answers and the critical instruction, I'm ready to:

Sprint 0 (30 min) - Create schema, types, migration

Sprint 1 (2-3 hrs) - Build all 5 API endpoints with security

Sprint 2 (2-3 hrs) - Build UI components + integrate into editor

Sprint 3 (1-2 hrs) - Enhance AI to use templates

Each sprint will conclude with:

âœ… Acceptance criteria checklist

ðŸ“ Summary of what was implemented

â“ Any blockers or questions for next phase

I will not begin coding until you:

Answer the questions above (or confirm assumptions)

Provide the "one last piece of critical instruction about the first phase"

Ready when you are! ðŸŽ¯

Do not begin working until I answer your other questions but this is the answer to number 8.

Add Transactional Safety

In Sprint 1: Task 1.3 (the "Recycle" endpoint), you are performing multiple database writes:

UPDATE (to shift scene orders)

INSERT (to create the new scene)

UPDATE (to increment usageCount on the template)

(Potentially) UPDATE (to auto-link media)

If step 1 succeeds but step 2 fails, you've corrupted the project's scene order.

Recommendation: Wrap this logicâ€”and the "Save As" logicâ€”in a database transaction.

Sprint 1, Task 1.3 (Revised Logic):

TypeScript

// Implementation Logic:

await db.transaction(async (tx) => {

// 1. Verify project (use 'tx')

// 2. Fetch template (use 'tx')

// 3. Security checks

// 4. Media Validation & Orphan Cleanup (use 'tx')

// 5. Apply customizations

// 6. Add metadata

// 7. Determine scene order (use 'tx')

let finalOrder;

// ... (logic for max order or shifting)

if (requestedOrder !== undefined) {

await tx.update(projectScenes)... // Use tx

}

// 8. Create new scene (use 'tx')

const [newScene] = await tx.insert(projectScenes)... // Use tx

// 9. Update template analytics (use 'tx')

await tx.update(sceneTemplates)... // Use tx

// 10. (NEW) Create version history for rollback

await tx.insert(portfolioVersions).values({

projectId: projectId,

changeType: 'scene_recycled',

// ... (add before/after state if your schema supports it)

});

// 'newScene' and 'warnings' are passed out of the transaction

return { newScene, warnings };

});

// The transaction result is what you return in the response.

return res.status(201).json(transactionResult);

This is a minor addition that provides critical "Undo" capability and ensures atomicity.

CE





Assistant

50 minutes ago



Read 15 files



Understood! Thank you for providing the critical instruction about transactional safety.

I've noted that for Sprint 1, Task 1.3 (the "Recycle" endpoint), I must wrap all database operations in a db.transaction() to ensure atomicity. This prevents data corruption if any step fails mid-process.

Key points I've captured:

Wrap in transaction: All database writes (UPDATE for scene order shifting, INSERT for new scene, UPDATE for template analytics, and any media auto-linking) must occur within a single transaction using db.transaction(async (tx) => { ... })

Use tx for all queries: Replace all db.query, db.insert, db.update calls with tx.query, tx.insert, tx.update inside the transaction block

Add version history: Insert a record into portfolioVersions (or similar audit table) to enable rollback capability, capturing the changeType: 'scene_recycled' and before/after state

Return transaction result: The transaction returns { newScene, warnings } which becomes the API response

Same pattern for "Save As": The template creation endpoint (Sprint 1, Task 1.1) should also use transactions when creating the template + updating related metadata

This ensures ACID compliance and prevents scenarios like:

Scene order shifts succeed but new scene insert fails â†’ project left with gaps in order

Template analytics update fails but scene was created â†’ usage count out of sync

Media linking partially completes â†’ orphaned references

I'm ready to proceed once you answer questions 1-7. I will implement this transactional safety pattern in both the Recycle endpoint and Save As endpoint as part of Sprint 1's backend implementation.

Should I wait for your answers to the remaining questions before beginning any work, or would you like me to start preparing the implementation plan while we clarify those details?





âœ… Infrastructure Verification Complete

I've searched the codebase and verified all your concerns. Here are the answers:



1. Tenant Middleware âœ… ACTIVE

req.tenantId is populated by tenantMiddleware in server/middleware/tenant.ts

Currently uses DEFAULT_TENANT_ID = 'tnt_revenueparty_default' for all requests (single-tenant stub)

The infrastructure is production-ready; your plan's tenant isolation will work correctly

2. Media Library âœ… FULLY IMPLEMENTED

The media_library table exists with:



tenantId (text, required, FK to tenants with cascade)

projectId (text, optional, FK to projects with set null)

Already being used in production

Existing media validation pattern (from scene creation endpoint, line 1784):



// This exact pattern already exists and works

const mediaRecords = await db.query.mediaLibrary.findMany({

  where: and(

    inArray(mediaLibrary.id, Array.from(mediaIdsToValidate)),

    eq(mediaLibrary.tenantId, tenantId)

  )

});

// Auto-links unlinked media to projects

const unlinkedMedia = mediaRecords.filter(m => !m.projectId);

if (unlinkedMedia.length > 0) {

  await db.update(mediaLibrary)

    .set({ projectId })

    .where(inArray(mediaLibrary.id, unlinkedMedia.map(m => m.id)));

}



Your plan can reuse this exact security pattern âœ…



3. ProjectSceneEditor Integration âœ… LOCATED

File exists at client/src/pages/admin/ProjectSceneEditor.tsx



Current structure:



Scene list rendered in cards (lines 1484-1520)

"Add Scene" button opens a dialog

Scene actions include Edit, Delete, Duplicate buttons

Best integration point:

Add "Add from Library" button next to the existing "Add Scene" functionality, likely in the scene list header area. The component already has state management for dialogs.



4. AI Endpoint âœ… CONFIRMED

Endpoint: POST /api/portfolio/generate-enhanced (line 2459)

Media library already loaded around line 2560:

const availableMediaLibrary = await db.query.mediaLibrary.findMany({

  where: eq(mediaLibrary.tenantId, req.tenantId)

});



Prompt context built around lines 2560-2620

Perfect spot to inject template library after media library loading

5. Database Migration Strategy âœ… STANDARD APPROACH

Use npm run db:push (with --force if needed)



This is the standard approach in your codebase:



Used in scripts/build-production.sh

Drizzle configured in drizzle.config.ts with out: "./migrations"

No manual migration files needed for this feature

6. Testing Expectations âœ… EXISTING PATTERNS

Your codebase already has:



Supertest for API testing (tests/integration/admin-crud.test.ts)

Playwright for E2E tests

Vitest for unit tests

Transaction-based test isolation

Recommendation for this feature:



Sprint 1 checkpoint: Manually test with curl (quick validation)

Optional: Write integration tests later if this becomes a critical path

No need to block on tests for initial implementation.



7. Preview Image Strategy âœ… MATCHES YOUR PLAN

Your auto-generation strategy is already the standard pattern:



Implementation:



let finalPreviewUrl = previewImageUrl; // User-provided override

if (!finalPreviewUrl && sceneConfig.content?.url) {

  // Use scene's primary media as preview

  finalPreviewUrl = sceneConfig.content.url;

} else if (!finalPreviewUrl && sceneConfig.content?.images?.[0]?.url) {

  // Use first gallery image as preview

  finalPreviewUrl = sceneConfig.content.images[0].url;

}

// finalPreviewUrl can be null if no media exists



This matches your comprehensive spec exactly âœ…



ðŸŽ¯ Summary: All Green Lights

Question	Status	Notes

1. Tenant middleware	âœ… Active	req.tenantId populated, uses DEFAULT_TENANT_ID

2. Media library	âœ… Production	Full tenantId/projectId support, validation exists

3. ProjectSceneEditor	âœ… Located	Integration point identified

4. AI endpoint	âœ… Confirmed	Line 2459, media library already loaded

5. Migration strategy	âœ… Standard	Use npm run db:push --force

6. Testing	âœ… Optional	Manual curl testing for Sprint 1, integration tests later

7. Preview images	âœ… Matches plan	Auto-generate from content.url â†’ images[0].url â†’ null

Your Implementation Plan v2.1 is fully validated and ready to execute. All infrastructure dependencies exist and work correctly.



Ready to begin implementation?





Here are the ansers to my 7 questions. With this done, make your final reflections announce the acceptance criteria of your first sprint, and begin working.

CE





Assistant

47 minutes ago





Read 13 files



ðŸŽ¯ Final Reflection & Sprint 0 Acceptance Criteria

Infrastructure Verification Summary

All 7 questions answered âœ…. The codebase is production-ready for this feature:

Tenant isolation: Fully operational via req.tenantId middleware

Media Library: Complete with tenantId/projectId FK relationships and existing validation patterns

Integration points: ProjectSceneEditor.tsx identified, AI endpoint at line 2459 confirmed

Database strategy: Standard npm run db:push --force approach

Testing: Manual curl for Sprint 1, integration tests optional

Preview images: Auto-generation strategy matches spec (content.url â†’ images[0].url â†’ null)

Critical Instruction Applied

Transactional Safety: All multi-step database operations (scene recycling, template creation) will be wrapped in db.transaction(async (tx) => {...}) to ensure atomicity and enable rollback via portfolio_versions audit trail.

ðŸ“‹ Sprint 0 Acceptance Criteria (30 minutes)

Goal: Create foundation schema, types, and migration for Scene Template Library

Acceptance Criteria Checklist

 AC-0.1: scene_templates table created with all required fields

id, tenantId, name, description, sceneConfig, tags, previewImageUrl, createdBy, usageCount, isPublic, createdAt, updatedAt

Proper indexes on tenantId, tags, usageCount, createdAt

Foreign key to tenants with CASCADE delete

 AC-0.2: TypeScript types exported from @shared/schema

SceneTemplate (select type)

InsertSceneTemplate (insert type)

UpdateSceneTemplate (partial update type)

 AC-0.3: Migration applied successfully

npm run db:push --force completes without errors

Table visible in database

Indexes created

 AC-0.4: Types importable in server code

No TypeScript compilation errors

sceneTemplates table accessible via Drizzle ORM

Deliverables

Updated shared/schema.ts with table definition

Migration SQL generated in migrations/ folder

Types available for import: import { sceneTemplates, type SceneTemplate } from '@shared/schema'