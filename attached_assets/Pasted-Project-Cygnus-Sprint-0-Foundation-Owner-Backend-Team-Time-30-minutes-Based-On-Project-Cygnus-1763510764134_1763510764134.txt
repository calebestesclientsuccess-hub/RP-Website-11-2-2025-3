Project Cygnus - Sprint 0: Foundation

Owner: Backend Team
Time: 30 minutes
Based On: Project Cygnus Technical Specification v2.1

1. Sprint Goal

The sole focus of this sprint is to establish the core database schema and type-safety for the new scene_templates table. This is the foundational data structure that all subsequent backend, frontend, and AI tasks will depend on.

2. Technical Tasks

$$0.1$$

 Database Schema Implementation

Modify shared/schema.ts to add the new sceneTemplates table.

Schema Definition:

// in shared/schema.ts
// ... imports (pgTable, varchar, text, jsonb, integer, timestamp, index, etc.)
// ... existing schema (projects, projectScenes, etc.)

export const sceneTemplates = pgTable("scene_templates", {
  // Primary identifier
  id: varchar("id").primaryKey().$defaultFn(() => `tmpl_${nanoid(12)}`),
  
  // CRITICAL: Tenant isolation
  tenantId: varchar("tenant_id")
    .notNull()
    .references(() => tenants.id, { onDelete: "cascade" }),
  
  // Template metadata
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  
  // The complete scene blueprint (copied from project_scenes.sceneConfig)
  sceneConfig: jsonb("scene_config").$type<SceneConfig>().notNull(),
  
  // Visual preview for gallery UI
  previewImageUrl: varchar("preview_image_url", { length: 2048 }),
  
  // Categorization and search
  tags: text("tags").array().default([]), // Correct Drizzle syntax for text array
  category: varchar("category", { length: 100 }), // e.g., "hero", "testimonial", "gallery"
  
  // Source tracking (optional - which scene was this template created from?)
  sourceProjectId: varchar("source_project_id").references(() => projects.id, { onDelete: "set null" }),
  sourceSceneId: varchar("source_scene_id").references(() => projectScenes.id, { onDelete: "set null" }),
  
  // Usage analytics
  usageCount: integer("usage_count").default(0).notNull(),
  lastUsedAt: timestamp("last_used_at"),
  
  // Auditing
  createdAt: timestamp("created_at").defaultNow().notNull(),
  createdBy: varchar("created_by").references(() => users.id, { onDelete: "set null" }),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  
  // Schema versioning for migrations
  schemaVersion: varchar("schema_version", { length: 10 }).default("1.0").notNull(),
});

// Indexes for performance
export const sceneTemplatesIndexes = [
  // Fast tenant filtering
  index("scene_templates_tenant_id_idx").on(sceneTemplates.tenantId),
  
  // Search by category
  index("scene_templates_category_idx").on(sceneTemplates.category),
  
  // Full-text search on name/description
  index("scene_templates_search_idx").on(sceneTemplates.name, sceneTemplates.description),
];



$$0.2$$

 Zod Schemas and TypeScript Types

In the same file (shared/schema.ts), define the Zod schemas for validation and export the new TypeScript types.

// ... after table definition

// Zod schemas for validation
export const insertSceneTemplateSchema = createInsertSchema(sceneTemplates)
  .omit({ 
    id: true, 
    createdAt: true, 
    updatedAt: true,
    usageCount: true,
    lastUsedAt: true,
  })
  .extend({
    name: z.string().min(3, "Template name must be at least 3 characters").max(255),
    description: z.string().max(1000).optional(),
    sceneConfig: sceneConfigSchema, // Reuse existing validation from projectScenes
    tags: z.array(z.string()).max(10).optional(),
    category: z.enum(["hero", "testimonial", "gallery", "split", "text", "media", "other"]).optional(),
  });

export type InsertSceneTemplate = z.infer<typeof insertSceneTemplateSchema>;
export type SceneTemplate = typeof sceneTemplates.$inferSelect;



$$0.3$$

 Migration

Run the Drizzle migration to push the schema changes to the database:

npm run db:push --force



Verify the table and its indexes exist in your PostgreSQL database.

3. Definition of Done

Sprint 0 is complete when:

The scene_templates table and its indexes exist in the database.

The insertSceneTemplateSchema, InsertSceneTemplate, and SceneTemplate types are exported from shared/schema.ts.

The code is committed to version control.